<script>
  let port, reader, writer, readLoopCancel;

  const logEl = document.getElementById('log');
  const connectBtn = document.getElementById('connectBtn');
  const disconnectBtn = document.getElementById('disconnectBtn');
  const sendBtn = document.getElementById('sendBtn');
  const interruptBtn = document.getElementById('interruptBtn');
  const softResetBtn = document.getElementById('softResetBtn');
  const jsonInput = document.getElementById('jsonInput');

  function log(...args) {
    logEl.value += args.join(' ') + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  async function connect() {
    try {
      // 1) Choose port and open
      port = await navigator.serial.requestPort({
        // filters: [{ usbVendorId: 0x2E8A }] // optional
      });
      await port.open({ baudRate: 115200 });

      // 2) Writer
      writer = port.writable.getWriter();

      // 3) Reader with buffered line splitter
      const decoder = new TextDecoderStream();
      readLoopCancel = new AbortController();
      port.readable.pipeTo(decoder.writable).catch(()=>{});

      let buffer = "";
      const lineSplitter = new TransformStream({
        transform(chunk, controller) {
          buffer += chunk;
          let idx;
          while ((idx = buffer.indexOf("\n")) >= 0) {
            const line = buffer.slice(0, idx).replace(/\r$/, "");
            if (line.length) controller.enqueue(line);
            buffer = buffer.slice(idx + 1);
          }
        },
        flush(controller) {
          if (buffer.length) controller.enqueue(buffer);
        }
      });

      const inputStream = decoder.readable.pipeThrough(lineSplitter);
      reader = inputStream.getReader({ signal: readLoopCancel.signal });

      // 4) Read loop
      (async () => {
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            if (value !== undefined && value.length) log("<<", value);
          }
        } catch (e) {
          if (e.name !== 'AbortError') log("Read error:", e.message);
        }
      })();

      // UI state
      connectBtn.disabled = true;
      disconnectBtn.disabled = false;
      sendBtn.disabled = false;
      interruptBtn.disabled = false;
      softResetBtn.disabled = false;

      log("‚úÖ Connected");
    } catch (e) {
      log("Connect error:", e.message);
    }
  }

  async function disconnect() {
    try {
      if (reader) { readLoopCancel?.abort(); try { await reader.cancel(); } catch {} reader = null; }
      if (writer) { try { writer.releaseLock(); } catch {} writer = null; }
      if (port)   { try { await port.close(); } catch {} port = null; }
    } finally {
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
      sendBtn.disabled = true;
      interruptBtn.disabled = true;
      softResetBtn.disabled = true;
      log("üîå Disconnected");
    }
  }

  async function sendLine(str) {
    if (!writer) return;
    const data = new TextEncoder().encode(str + "\n");
    await writer.write(data);
    log(">>", str);
  }

  async function sendJSON() {
    try {
      const raw = jsonInput.value.trim();
      JSON.parse(raw);            // validate
      await sendLine(raw);        // newline-terminated JSON
    } catch (e) {
      log("JSON error:", e.message);
    }
  }

  async function sendCtrlC() {
    if (!writer) return;
    const ctrlC = new Uint8Array([0x03]); // Ctrl-C
    await writer.write(ctrlC);
    log(">> [Ctrl-C]");
  }

  async function sendCtrlD() {
    if (!writer) return;
    const ctrlD = new Uint8Array([0x04]); // Ctrl-D
    await writer.write(ctrlD);
    log(">> [Ctrl-D soft reboot]");
  }

  connectBtn.addEventListener('click', connect);
  disconnectBtn.addEventListener('click', disconnect);
  sendBtn.addEventListener('click', sendJSON);
  interruptBtn.addEventListener('click', sendCtrlC);
  softResetBtn.addEventListener('click', sendCtrlD);

  // Feature detection
  if (!('serial' in navigator)) {
    log("‚ùå This browser doesn't support Web Serial API. Use Chrome/Edge over HTTPS or localhost.");
    connectBtn.disabled = true;
  }
</script>